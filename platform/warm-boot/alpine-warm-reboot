#!/bin/bash -e

REBOOT_USER=""
REBOOT_TIME=$(date)
REBOOT_CAUSE_FILE="/host/reboot-cause/reboot-cause.txt"
WARM_DIR=/host/warmboot
REDIS_FILE=dump.rdb
CONFIG_DB_FILE=/etc/sonic/config_db.json
REBOOT_SCRIPT_NAME="warm-reboot"
REBOOT_TYPE="${REBOOT_SCRIPT_NAME}"
SHUTDOWN_ORDER_FILE="/etc/sonic/${REBOOT_TYPE}_order"
VERBOSE=no
FORCE=no
IGNORE_ASIC=no
IGNORE_DB_CHECK=no
STRICT=no
REBOOT_METHOD="/sbin/kexec -e"
ASSISTANT_IP_LIST=""
ASSISTANT_SCRIPT="/usr/local/bin/neighbor_advertiser"
LAG_KEEPALIVE_SCRIPT="/usr/local/bin/lag_keepalive.py"
WATCHDOG_UTIL="/usr/local/bin/watchdogutil"
DEVPATH="/usr/share/sonic/device"
PLATFORM=$(sonic-cfggen -H -v DEVICE_METADATA.localhost.platform)
PLATFORM_PLUGIN="${REBOOT_TYPE}_plugin"
LOG_SSD_HEALTH="/usr/local/bin/log_ssd_health"
PLATFORM_FWUTIL_AU_REBOOT_HANDLE="platform_fw_au_reboot_handle"
PLATFORM_REBOOT_PRE_CHECK="platform_reboot_pre_check"
SSD_FW_UPDATE="ssd-fw-upgrade"
SSD_FW_UPDATE_BOOT_OPTION=no
TAG_LATEST=yes
DETACH=no
LOG_PATH="/var/log/${REBOOT_TYPE}.txt"
UIMAGE_HDR_SIZE=64
REQUIRE_TEAMD_RETRY_COUNT=no

# Require 100M available on the hard drive for warm reboot temp files,
# Size is in 1K blocks:
MIN_HD_SPACE_NEEDED=100000

EXIT_SUCCESS=0
EXIT_FAILURE=1
EXIT_NOT_SUPPORTED=2
EXIT_FILE_SYSTEM_FULL=3
EXIT_NEXT_IMAGE_NOT_EXISTS=4
EXIT_ORCHAGENT_SHUTDOWN=10
EXIT_SYNCD_SHUTDOWN=11
EXIT_COUNTERPOLL_DELAY_FAILURE=14
EXIT_DB_INTEGRITY_FAILURE=15
EXIT_NO_CONTROL_PLANE_ASSISTANT=20
EXIT_SONIC_INSTALLER_VERIFY_REBOOT=21
EXIT_PLATFORM_FW_AU_FAILURE=22
EXIT_TEAMD_RETRY_COUNT_FAILURE=23

VERBOSE=yes

function error()
{
    echo $@ >&2
}

function debug()
{
    if [[ x"${VERBOSE}" == x"yes" ]]; then
        echo $(date) $@
    fi
    logger "$@"
}

function showHelpAndExit()
{
    echo "Usage: ${REBOOT_SCRIPT_NAME} [options]"
    echo "    -h,-? : get this help"
    echo "    -v    : turn on verbose"
    echo "    -f    : force execution - ignore Orchagent RESTARTCHECK failure"
    echo "    -i    : force execution - ignore ASIC MD5-checksum-verification"
    echo "    -d    : force execution - ignore database integrity check"
    echo "    -r    : reboot with /sbin/reboot"
    echo "    -k    : reboot with /sbin/kexec -e [default]"
    echo "    -x    : execute script with -x flag"
    echo "    -c    : specify control plane assistant IP list"
    echo "    -s    : strict mode: do not proceed without:"
    echo "            - control plane assistant IP list."
    echo "    -t    : Don't tag the current kube images as latest"
    echo "    -D    : detached mode - closing terminal will not cause stopping reboot"
    echo "    -u    : include ssd-upgrader-part in boot options"
    echo "    -n    : don't require peer devices to be running SONiC with retry count feature [default]"
    echo "    -N    : require peer devices to be running SONiC with retry count feature"

    exit "${EXIT_SUCCESS}"
}

function recover_issu_bank_file()
{
    debug "Recovering the (${ISSU_BANK_FILE}) file"
    docker exec -i syncd sx_api_dbg_generate_dump.py
    issu_bank_value=`docker exec -i syncd cat /tmp/sdkdump | grep 'ISSU Bank' | grep -o -E '[0-9]+'`
    printf $issu_bank_value > /host/warmboot/issu_bank.txt
}

function check_issu_bank_file()
{
    ISSU_BANK_FILE=/host/warmboot/issu_bank.txt

    if [[ ! -s "$ISSU_BANK_FILE" ]]; then
        error "(${ISSU_BANK_FILE}) does NOT exist or empty ..."
        recover_issu_bank_file
        return
    fi

    issu_file_chars_count=`stat -c %s ${ISSU_BANK_FILE}`;
    issu_file_content=`awk '{print $0}' ${ISSU_BANK_FILE}`

    if [[ $issu_file_chars_count != 1 ]] ||
        [[ "$issu_file_content" != "0" && "$issu_file_content" != "1" ]]; then
        error "(${ISSU_BANK_FILE}) is broken ..."
        recover_issu_bank_file
    fi
}

function backup_database()
{
    debug "Backing up database ..."
    # Dump redis content to a file 'dump.rdb' in warmboot directory
    mkdir -p $WARM_DIR
    # Delete keys in stateDB except FDB_TABLE|*, MIRROR_SESSION_TABLE|*, WARM_RESTART_ENABLE_TABLE|*, FG_ROUTE_TABLE|*
    sonic-db-cli STATE_DB eval "
        for _, k in ipairs(redis.call('keys', '*')) do
            if not string.match(k, 'FDB_TABLE|') and not string.match(k, 'WARM_RESTART_TABLE|') \
                                          and not string.match(k, 'MIRROR_SESSION_TABLE|') \
                                          and not string.match(k, 'FG_ROUTE_TABLE|') \
                                          and not string.match(k, 'WARM_RESTART_ENABLE_TABLE|') \
                                          and not string.match(k, 'VXLAN_TUNNEL_TABLE|') \
                                          and not string.match(k, 'BUFFER_MAX_PARAM_TABLE|') \
                                          and not string.match(k, 'BOOT_INFO') \
                                          and not string.match(k, 'SAI_KEY_LABEL_MAP') \
                                          and not string.match(k, 'WARM_RESTART') \
                                          and not string.match(k, 'HOST_STATS') \
                                          and not string.match(k, 'PORT_BREAKOUT') \
                                          and not string.match(k, 'SWITCH_CAPABILITY') \
                                          and not string.match(k, 'FAST_RESTART_ENABLE_TABLE|') then
                redis.call('del', k)
            end
        end
    " 0 > /dev/null

    # move all db data into the instance where APPL_DB locates
    target_db_inst=`centralize_database APPL_DB`

    # Dump redis content to a file 'dump.rdb' in warmboot directory
    docker cp database:/var/lib/$target_db_inst/$REDIS_FILE $WARM_DIR
    STATE=$(timeout 5s docker exec database rm /var/lib/$target_db_inst/$REDIS_FILE; if [[ $? == 124 ]]; then echo "timed out"; fi)
    if [[ x"${STATE}" == x"timed out" ]]; then
        error "Timed out during attempting to remove Redis dump file from database container"
    fi
}

function is_secureboot() {
    grep -Eq 'secure_boot_enable=[1y]' /proc/cmdline
}

function setup_reboot_variables()
{
    # Kernel and initrd image
    HWSKU=$(show platform summary --json | python -c 'import sys, json; print(json.load(sys.stdin)["hwsku"])')
    NEXT_SONIC_IMAGE=$(sonic-installer list | grep "Next: " | cut -d ' ' -f 2)
    IMAGE_PATH="/host/image-${NEXT_SONIC_IMAGE#SONiC-OS-}"
    if grep -q aboot_platform= /host/machine.conf; then
        if is_secureboot; then
            KERNEL_IMAGE=""
            BOOT_OPTIONS="SONIC_BOOT_TYPE=${BOOT_TYPE_ARG} secure_boot_enable=1"
        else
            KERNEL_IMAGE="$(ls $IMAGE_PATH/boot/vmlinuz-*)"
            BOOT_OPTIONS="$(cat "$IMAGE_PATH/kernel-cmdline" | tr '\n' ' ') SONIC_BOOT_TYPE=${BOOT_TYPE_ARG}"
        fi
        INITRD=$(echo $KERNEL_IMAGE | sed 's/vmlinuz/initrd.img/g')
    elif grep -q onie_platform= /host/machine.conf; then
        if [ -r /host/grub/grub.cfg ]; then
            KERNEL_OPTIONS=$(cat /host/grub/grub.cfg | sed "/$NEXT_SONIC_IMAGE'/,/}/"'!'"g" | grep linux)
            KERNEL_IMAGE="/host$(echo $KERNEL_OPTIONS | cut -d ' ' -f 2)"
            BOOT_OPTIONS="$(echo $KERNEL_OPTIONS | sed -e 's/\s*linux\s*/BOOT_IMAGE=/') SONIC_BOOT_TYPE=${BOOT_TYPE_ARG}"
            INITRD=$(echo $KERNEL_IMAGE | sed 's/vmlinuz/initrd.img/g')
        # Handle architectures supporting Device Tree
        elif [ -f /sys/firmware/devicetree/base/chosen/bootargs ]; then
            KERNEL_IMAGE="$(ls $IMAGE_PATH/boot/vmlinuz-*)"
            BOOT_OPTIONS="$(cat /sys/firmware/devicetree/base/chosen/bootargs | sed 's/.$//') SONIC_BOOT_TYPE=${BOOT_TYPE_ARG}"
            INITRD=$(echo $KERNEL_IMAGE | sed 's/vmlinuz/initrd.img/g')

            # If initrd is a U-Boot uImage, remove the uImage header
            if file ${INITRD} | grep -q uImage; then
                INITRD_RAW=$(echo $KERNEL_IMAGE | sed 's/vmlinuz/initrd-raw.img/g')
                tail -c+$((${UIMAGE_HDR_SIZE}+1)) < ${INITRD} > ${INITRD_RAW}
                INITRD=${INITRD_RAW}
            fi
        else
            error "Unknown ONIE platform bootloader. ${REBOOT_TYPE} is not supported."
            exit "${EXIT_NOT_SUPPORTED}"
        fi
    else
        error "Unknown bootloader. ${REBOOT_TYPE} is not supported."
        exit "${EXIT_NOT_SUPPORTED}"
    fi
    if [[ x"${SSD_FW_UPDATE_BOOT_OPTION}" == x"yes" ]]; then
        local sonic_dev=$(blkid -L SONiC-OS)
        local fstype=$(blkid -o value -s TYPE ${sonic_dev})
        BOOT_OPTIONS="${BOOT_OPTIONS} ssd-upgrader-part=${sonic_dev},${fstype}"
    fi
}

function load_aboot_secureboot_kernel() {
    local next_image="$IMAGE_PATH/sonic.swi"
    echo "Loading next image from $next_image"
    unzip -qp "$next_image" boot0 | \
        swipath=$next_image kexec=true loadonly=true ENV_EXTRA_CMDLINE="$BOOT_OPTIONS" bash -
}

function invoke_kexec() {
    /sbin/kexec -l "$KERNEL_IMAGE" --initrd="$INITRD" --append="$BOOT_OPTIONS" $@
}

function load_kernel() {
    # Load kernel into the memory
    invoke_kexec -a 
}

function load_kernel_secure() {
    # Load kernel into the memory secure
    # -s flag is for enforcing the new load kernel(vmlinuz) to be signed and verify.
    # not using -a flag, this flag can fallback to an old kexec load that do not support Secure Boot verification
    invoke_kexec -s
}

function unload_kernel()
{
    # Unload the previously loaded kernel if any loaded
    if [[ "$(cat /sys/kernel/kexec_loaded)" -eq 1 ]]; then
        /sbin/kexec -u
    fi
}

function save_counters_folder() {
    if [[ "$REBOOT_TYPE" = "warm-reboot" ]]; then
        debug "Saving counters folder before warmboot..."
        counters_folder="/host/counters"
        counters_cache="/tmp/cache"
        if [[ ! -d $counters_folder ]]; then
            mkdir $counters_folder
        fi
        if [[ -d $counters_cache ]]; then
           cp -rf $counters_cache $counters_folder
        fi
    fi
}

# main starts here

debug "Starting $REBOOT_TYPE"

sonic_asic_type=$(sonic-cfggen -y /etc/sonic/sonic_version.yml -v asic_type)

BOOT_TYPE_ARG="warm"

# We are fully committed to reboot from this point on because critical
# service will go down and we cannot recover from it.
set +e

# disable trap-handlers which were set before
trap '' EXIT HUP INT QUIT TERM KILL ABRT ALRM

save_counters_folder

unload_kernel

setup_reboot_variables

if is_secureboot && grep -q aboot_machine= /host/machine.conf; then
    load_aboot_secureboot_kernel
else
    # check if secure boot is enable in UEFI 
    CHECK_SECURE_UPGRADE_ENABLED=0
    SECURE_UPGRADE_ENABLED=$(bootctl status 2>/dev/null | grep -c "Secure Boot: enabled") || CHECK_SECURE_UPGRADE_ENABLED=$?
    if [[ CHECK_SECURE_UPGRADE_ENABLED -ne 0 ]]; then
        debug "Loading kernel without secure boot"
        load_kernel
    else
        debug "Loading kernel with secure boot"
        load_kernel_secure
    fi
fi

# Stop any timers to prevent any containers starting in the middle of the process.
TIMERS=$(systemctl list-dependencies --plain sonic-delayed.target | sed 1d)
for timer in ${TIMERS}; do
    debug "Stopping ${timer} ..."
    systemctl stop ${timer}
    debug "Stopped ${timer} ..."
done

if [[ -f ${SHUTDOWN_ORDER_FILE} ]]; then
    SERVICES_TO_STOP="$(cat ${SHUTDOWN_ORDER_FILE})"
else
    error "No shutdown sequence file found: ${SHUTDOWN_ORDER_FILE}"
    exit "${EXIT_FAILURE}"
fi

for service in ${SERVICES_TO_STOP}; do
    # Skip the masked services
    state=$(systemctl is-enabled ${service})
    if [[ $state == "masked" ]]; then
        continue
    fi

    debug "Stopping ${service} ..."

    if [[ "${service}" = "nat" || "${service}" = "sflow" || "${service}" = "lldp" ]]; then
        container kill "${service}"  &> /dev/null || debug "Docker ${service} is not running ($?) ..."
    fi

    if [[ "${service}" = "syncd" ]]; then
        systemctl stop ${service} || debug "Ignore stopping ${service} service error $?"
    else
        systemctl stop ${service}
    fi

    debug "Stopped ${service}"

    if [[ "${service}" = "swss" ]]; then
        backup_database
    fi
done

# Stop the docker container engine. Otherwise we will have a broken docker storage
systemctl stop docker.service || debug "Ignore stopping docker service error $?"

# Update the reboot cause file to reflect that user issued this script
# Upon next boot, the contents of this file will be used to determine the
# cause of the previous reboot
echo "User issued '${REBOOT_SCRIPT_NAME}' command [User: ${REBOOT_USER}, Time: ${REBOOT_TIME}]" > ${REBOOT_CAUSE_FILE}

# Wait until all buffers synced with disk
sync
sleep 1
sync

# sync the current system time to CMOS
if [ -x /sbin/hwclock ]; then
    /sbin/hwclock -w || /bin/true
fi


if [[ -x ${DEVPATH}/${PLATFORM}/${PLATFORM_FWUTIL_AU_REBOOT_HANDLE} ]]; then
    debug "Handling task file for boot type ${REBOOT_TYPE}"
    ${DEVPATH}/${PLATFORM}/${PLATFORM_FWUTIL_AU_REBOOT_HANDLE} ${REBOOT_TYPE} || PLATFORM_FW_AU_RC=$?
    if [[ $PLATFORM_FW_AU_RC -ne 0 ]]; then
        debug "ERROR: Failed to handle the platform firmware auto-update for ${REBOOT_TYPE} Exit code: $PLATFORM_FW_AU_RC"
        exit "${EXIT_PLATFORM_FW_AU_FAILURE}"
    fi
fi


# Enable Watchdog Timer
if [ -x ${WATCHDOG_UTIL} ]; then
    debug "Enabling Watchdog before ${REBOOT_TYPE}"
    ${WATCHDOG_UTIL} arm
fi

# Run platform specific reboot plugin
if [ -x ${DEVPATH}/${PLATFORM}/${PLATFORM_PLUGIN} ]; then
    debug "Running ${PLATFORM} specific plugin..."
    ${DEVPATH}/${PLATFORM}/${PLATFORM_PLUGIN}
fi

# Reboot: explicitly call Linux native reboot under sbin
debug "Rebooting with ${REBOOT_METHOD} to ${NEXT_SONIC_IMAGE} ..."

LOGS_ON_TMPFS=0
df --output=fstype /var/log* | grep -c 'tmpfs' || LOGS_ON_TMPFS=$?
if [[ LOGS_ON_TMPFS -eq 0 ]]; then
    debug "Backup shutdown logs to /host/logs_before_reboot"
    mkdir -p /host/logs_before_reboot || /bin/true
    # maxdepth 2: find files within 2 nested directories (eg. /var/log/ and /var/log/swss/)
    # mmin 30: find files written in past 30 minutes
    find /var/log -maxdepth 2 -mmin -30 -type f | xargs -I {} cp {} /host/logs_before_reboot/ || /bin/true
fi

exec ${REBOOT_METHOD}

# Should never reach here
error "${REBOOT_TYPE} failed!"
exit "${EXIT_FAILURE}"
